package com.jdbc.dao;

import java.sql.Connection;
import java.sql.PreparedStatement;
import java.sql.ResultSet;
import java.sql.SQLException;
import java.sql.Statement;
import java.util.ArrayList;
import java.util.List;

import org.apache.log4j.Logger;

import com.jdbc.pojos.Role;
import com.jdbc.util.ConnectionFactory;

public class RoleRepository {
	
	/*-takes an SQL statement in as a string, executes it, and returns the result
	 * -allows SQL injection (not precompiled before executing on DB) so it is bad to use
	 * If you must, use it for queries which do not take parameters like a find all method*/
	
	public List<Role> findAll(){
		List<Role> roles = new ArrayList<Role>();
		try(Connection conn = ConnectionFactory.getInstance().getConnection()){
			String query = "SELECT * FROM ROLES";
			Statement statement = conn.createStatement();
			
			ResultSet rs = statement.executeQuery(query);
			while(rs.next()){
				Role temp = new Role(rs.getInt(1), rs.getString("Title"));
				roles.add(temp);
			}
		} catch(SQLException e){
			e.printStackTrace();
		}
		return roles;
	}
	
	/*
	 * PREPARED STATEMENT
	 * -extends statement
	 * -executes a pre-compiled SQL statement
	 * -efficient for statements that will execute multiple times and have variables
	 * */
	
	public Role getById(int id)
	{
		Role r = null;
		try(Connection conn = ConnectionFactory.getInstance().getConnection()){
			String query = "SELECT * FROM ROLES WHERE RID = ?";
			PreparedStatement ps = conn.prepareStatement(query);
			ps.setInt(1, id);
			ResultSet rs = ps.executeQuery();
			if(rs.next())
			{
				r = new Role(rs.getInt(1), rs.getString(2));
				/*r.setId(rs.getInt(1));
				r.setTitle(rs.getString(2));*/
			}
		}
		catch (SQLException e)
		{
			e.printStackTrace();
		}
		return r;
	}
	
	/*INSERT DATA WITH PREPARED STATEMENTS*/
	public Role save(String title){
		Role r = new Role();
		try(Connection conn = ConnectionFactory.getInstance().getConnection()){
			/*
			 * When adding or updating data, we must take into account TRANSACTION MANAGEMENT!
			 * WE MUST COMMIT!
			 * With connections, upon closing them, by default there
			 * is an autoCommit property
			 * that is set to true. we may want to turn this off to make sure that we handle 
			 * any issues that may arise during the TX before we commit
			 * */
			conn.setAutoCommit(false);
			String sql = "INSERT INTO ROLES(TITLE) VALUES (?)";
			//create String array holding names of cols that are autogenerated
			String[] keys = {"rid"};
			PreparedStatement ps = conn.prepareStatement(sql, keys);
			ps.setString(1, title);
			
			//QUERIES return ResultSet
			//UPDATES return int of num rows affected
			
			int numRows = ps.executeUpdate();
			if(numRows > 0)
			{
				ResultSet pk = ps.getGeneratedKeys();
				pk.next();
				r.setId(pk.getInt(1));
				r.setTitle(title);
				conn.commit(); 	//COMMIT YOUR CHANGES IF THEY'RE SUCCESSFUL
			}
		} catch(SQLException e)
		{
			e.printStackTrace();
		}
		return r;
	}
	
	public Role update(Role r)
	{
		//UPDATE ROLES SET TITLE = 'HR Representative' WHERE RID = ?;
		//param passed in will contain id of entity to be
		//changed WITH the new values to change it to
		try(Connection conn = ConnectionFactory.getInstance().getConnection()){
			conn.setAutoCommit(false);
			String sql = "UPDATE ROLES SET TITLE = ? WHERE RID = ?";
			
			PreparedStatement ps = conn.prepareStatement(sql);
			
			ps.setString(1, r.getTitle());
			ps.setInt(2, r.getId());
			
			int numRows = ps.executeUpdate();
			if(numRows > 0)
				conn.commit();
			else
				return null;
		}
		catch(SQLException e)
		{
			e.printStackTrace();
		}
		
		return r;
	}

}
