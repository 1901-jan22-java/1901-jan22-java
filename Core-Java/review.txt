why choose java?
can run on any operating system because of jvm
dont have to deal with memory management


OOP -
	Abstraction - abstract, interface
	Encapsulation - getters, setters, private instance variables, nested classes
	Inheritance - extends, implements
	Polymorphism - how we have different behavior capabilities with the same object, override/overload methods, covariant types

garbage collection - JVM manages, gc thread - "daemon" thread (never dies), 
			finalize(); called before garbage collection
			System.gc(); request to garbage collection

final vs finally vs finalize
finalize - called before garbage collection. end of a program
finally - end of a try/catch block. you do not need it. can be used for things that you always want to happen though. basically a fail safe
final - 	variable	cannot reassign variables
		method		cannot override method (can overload)
		class		cannot extend

Strings
	Immutable
	Stored in String Pool unless you create an object ("new" to instantiate)
	ex. 
		String s = "hello"; 		String pool
		String t = new String("hello");	
	
	String Builder and String Buffer (kinda like a mutable string)
	append (like concat)
	reverse()
	ex. StringBuilder sb = new StringBuilder("hello");
	sb.append(" world").reverse();

	String Buffer is synchronized 
	String Builder is not


Synchronized = only 1 thread can access at a time


Multithreading
	extend Thread class
	implement Runnable interface
	override run()
	call start() which is a member of Thread class
	if you want to run a thread, make a Thread class then implement the Runnable class
	used for serialization
	
Serialization - taking object state and converting it to stream of bytes
Deserialization - opposite of serialization
	Transient keyword for things you do not want to serialize
	Serial Version UID - generated for a serialized thing
More for transfer purposes, not for security

VARIABLE SCOPES
class - need 1 class to use variable
block - can be used inside that block
instance - need 1 instance to use variable
method - can be used in that method

DESIGN PATTERNS - solution to common problem in coding
basically a way to code. kind of like a style but it's a solution made from experience in coding
creational design pattern - provide solution to instantiate an object for situations
structural design pattern - different ways to create class structure
behavioral design pattern - interaction between objects and how to lose coupling

start up a thread you need to implement runnable or extend thread class
.start() the thread

thread = the execution of programs


Collection is the collection interface with list/set/queue
Collections has a bunch of static methods. Arrays.sort Arrays.asList
	a utility class, can be used on other entities

if you don't write a constructor, it'll have a default constructor where it just calls super()
if you write another method, it'll lose the default constructor
noargs constructor can be written, but it's not the same as default constructor since you dont need to write the default constructor


